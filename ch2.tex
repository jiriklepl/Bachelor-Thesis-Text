\chapter{Type inference for C}

One of the main problems of C is its weak type system and a lack of support of generic programming.
This leads to an extensive use of generic pointers and preprocessor macros which solves some of it,
but this solution does not make programming in C very pleasant. % FIXME: better wording pls

Generic (void) pointers can point to any data structure and thus they can be used in "generic" code
to work with virtually any data. But these pointers carry no type information and so that has to be
done by other means, for example enumerations.

One example of using void pointers can be `malloc' which without any type inference requires the user
to calculate the required themselves (this can seem to be trivial to do, but it still generates some code
noise and it is a possible source of bugs).

If we implement a generic data structure using macros, creating all required instances of
it and dedicated procedures working on them have to be instantiated explicitly by the user
which can lead to bloated and hard to read code.

One example of making "generic" data structures via macros is kernel's \lstinline{__KHASH_TYPE} macro (in `./khash.h'):

\begin{lstlisting}
#define __KHASH_TYPE(name, khkey_t, khval_t) \
	typedef struct { \
		khint_t n_buckets, size, n_occupied, upper_bound; \
		khint32_t *flags; \
		khkey_t *keys; \
		khval_t *vals; \
	} kh_##name##_t;
\end{lstlisting}

If we were to create an instance of this structure where \lstinline{khkey_t=int}, and \lstinline{khval_t=float},
we would have to use this macro to instantiate the structure explicitly:
\lstinline{__KHASH_TYPE(name, int, float)} and also to instantiate all the functions using it.

The lack of any type checking in this context allows the user to insert a wrong type/name to the macro
and all bugs caused by such an error could be very difficult to find.

This approach also requires explicit mention of the instance in the corresponding function calls

For example in this case we would clear the structure by calling
\lstinline{void kh_clear_<name>(const kh_<name>_t *h);}

% TIP: like queue.h?

But one of the biggest problems with the lack of generic features is the lack of type-checking
of definitions of these "generic" implementations, result of this being any bugs manifest only
when the macro holding the definition is expanded.

Another way of simulating generic features is usage of `unions', those provide better type safety
than both generic pointers and macros, but if we use them in contexts where they provide no added benefit
than making it possible to use multiple types, they bring with them the possibility of data size redundancy.

Adding generic programming features to C thus can help to debug programs written in this language and
to make writing generic code more user friendly and easier to maintain/expand. % FIXME: wording is evil here.

% TODO: use either the aforementioned  __KHASH_TYPE or queue to demonstrate this

Using type checking and type inference described in this thesis have effect very similar effect to instantiating
definitions via macro expansion, but with the benefit of brevity, catching bugs early and having fewer
requirements on mindfulness of the user (all of these effect can lead to less error-prone code).

% TODO: here demonstration

As we can see in the examples shown above the CHM implementation has semantically the same meaning as the C
implementation, but is much shorter and less demanding on the user.

\xxx{motivace: kde jsme, jak vypada kernelovej kod s hromadama maker, a kam se chceme dostat. Priklady kodu.}

\section{C99 types}

% TODO: http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf speaks about them

All C types

\section{C types in Hindley-Milner context}

All main C data types can be modeled as some type constants (with signedness/long specifiers or without)

Then we can model pointers as type constructors taking one type.
This approach makes it easy to model reference as a function that takes a type and returns a pointer to this type
and dereference as a function that takes a pointer to a type and returns the type.

The problem with C types in the context of HM type system is that C uses the const type specifier and its representation
in HM cannot be compatible with its C meaning.

One reason being that we can assign type `a` to `a` and also `const a' to `a', but not the other way around, and even
more importantly if we consider a const specifier a part of a type, and we allow applying const to any type, we have
to deal with reapplying const and that a function can be valid only if, if it has pointer parameters, those parameters
are pointers to non-const values, as otherwise modifying those values (even in nested calls) would disregard const.

Therefore const specifier cannot be part of the type (and so in this thesis we will ignore it as it has no meaning on
meaning of the code).

Types of C functions then can be modeled as functions taking a tuple of parameters and returning the return type of the
function.


\section{Polymorphic C}

There are some data structures and algorithms in the C standard that could be better represented using polymorphism instead of relying on
macros, an evidence of that could be popularity of languages like c++, d, rust, etc.

\section{Typeclasses in C}

Sometimes the same process we want to make requires different implementation of some parts of the algorithm
for each type. This can be achieved either by some run-time checking or some kind of overloading, and overloading via
constraint-based type classes in the context of C is proven to work as this mechanism sees heavy use in C++, for example,
where it is simulated via partial specializations of templates.

% TODO: https://mail.haskell.org/pipermail/beginners/2010-December/006057.html
